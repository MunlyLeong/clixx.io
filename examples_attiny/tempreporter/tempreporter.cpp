/* Simple Timer

A simple example of using timers.

*/

#define F_CPU 8000000UL

#include <stdio.h>
#include "clixxIO.hpp"
#include "tempreporter-config.hpp"

#include "core_AVR/softuart.h"
#include "core_AVR/iohelp.h"

#include <avr/interrupt.h>
#include <util/delay.h>

#define TEMP_OFFSET 17

#define D1_I PB3
#define D1_O PB4
#define D1_S PB0

#define D2_I PB2
#define D2_O PB1
#define D2_S PB5

class App : public clixxIOApp{

  public:
  
    void timerevent(){

    };
    
    void setup(){
        
    };
    
};

/** Initialise the specified analog pin
*
* This function initialises the ADC accessory as well as setting up the input
* pin attached to the ADC. The set up uses VCC as the reference voltage. If
* you need to change this do so after initialising all the ADC inputs you
* want to use.
*
* @param adc the ADC input to initialise.
*/
void adcInit(ANALOG adc) {
  // Make sure the ADC convertor is setup
  ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
  // Switch off digital for the appropriate pin
  uint8_t mask, didr;
  if(adc==ADC0) {
    mask = 1 << PINB5;
    didr = 1 << ADC0D;
    }
  else if(adc==ADC1) {
    mask = 1 << PINB2;
    didr = 1 << ADC1D;
    }
  else if(adc==ADC2) {
    mask = 1 << PINB4;
    didr = 1 << ADC2D;
    }
  else if(adc==ADC3) {
    mask = 1 << PINB5;
    didr = 1 << ADC3D;
    }
  else // ADC4 or invalid pin, just ignore it
    return;
  // Make sure the pin is an input and pull up is disabled
  PORTB &= ~mask;
  DDRB &= ~mask;
  // Disable digital input for the pin
  DIDR0 |= didr;
  }

/** Read a value from the analog input
*
* Read a 10 bit value from the specified input with option input skipping and
* averaging.
*
* @param adc the ADC input to read
* @param skip the number of samples to skip (read and ignore).
* @param average the number of samples to average (must be >= 1)
*
* @return the sample value.
*/
uint16_t adcRead(ANALOG adc, uint8_t skip, uint8_t average) {
  // Change the reference voltage and select input
  uint8_t muxval = adc;
  if(adc==ADC4) // Need 1.1V reference
    muxval = 0x80 | adc;
  ADMUX = muxval;
  // Start the conversion
  uint8_t count = skip + average;
  uint16_t value, total = 0;
  while(count) {
    // Start the conversion, then wait for it to finish
    ADCSRA |= (1 << ADSC);
    while(ADCSRA & (1 << ADSC));
    if(count<=average) {
      // Read the current value and add it to the running total
      value = ADCL;
      value = value | (ADCH << 8);
      total += value;
      }
    count--;
    }
  return (total / average);
}

/*
int getTemp(){
  ADCSRA |= (1 << ADSC);  //Start temperature conversion
  while (bit_is_set(ADCSRA, ADSC));  //Wait for conversion to finish
  byte low  = ADCL;
  byte high = ADCH;
  int temperature = (high << 8) | low;  //Result is in kelvin
  return temperature - 273 + TEMP_OFFSET;
}
*/

// Main program Section. Simply setup an App class and let it run
int main(){
 
  // App m;

	//softuart_init();
	//sei();
  
    Serial.begin();
	sei();
	
	softuart_puts("Hello - I am alive\n\r");

	adcInit(ADC4);

    Serial.puts("Adc initialised\n\r");

    DDRB |= (1<<D1_O);    	///PB5 /digital 13 is an output

	for (;;) {

		// Flashing LED
		PORTB |= (1<<D1_O);    		// Else turn pin on
		_delay_ms(200);    // Delay 2 millisecond
		PORTB &= ~(1<<D1_O);    		// Turn pin off
		_delay_ms(200);    // Delay 2 millisecond
		
		// Process Temperatures via ADC
		int temp = adcRead(ADC4,1,3);
		
		char str[25];
		snprintf(str, sizeof(str), "Temp=%d %d\n\r", temp,  temp - 273 + TEMP_OFFSET);
		Serial.puts(str);
		
	}

  //return m.run();

}

// Autogenerated interface between the event interface and application class
#include "tempreporter-callbacks.cpp"
